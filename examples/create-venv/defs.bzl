"""Exports a macro that invokes creates venv for ease of development"""

load("@rules_pyvenv//:venv.bzl", "py_venv")
load("@rules_python//python:defs.bzl", "py_binary")

def export_devenv(name, venv_location, deps, **kwargs):
    """Uses `py_venv` and some `.pth` magic on top.

    Args:
      name: standard one
      venv_location: see py_venv(venv_location=)
      deps: see py_venv(deps=)
      **kwargs: the rest
    """

    # The name of the python binary generated by `py_venv` macro.
    py_venv_name = name + "_venv"
    py_venv_output_json = "_" + py_venv_name + "_deps.json"
    py_venv(
        name = py_venv_name,
        always_link = True,
        venv_location = venv_location,
        deps = deps,
    )

    env = {
        # Below is a workaround to run `rules_pyvenv`s binary as a tool from our
        # `py_binary`, see
        #   https://github.com/cedarai/rules_pyvenv/blob/main/venv.bzl#L80-L85
        # These env variables are to be passed to the `py_binary` in the link above
        # that creates the venv. See `expand_venv.py` where we call it.
        "BUILD_ENV_INPUT": "$(location :" + py_venv_output_json + ")",
        "VENV_LOCATION": venv_location,
        # This `PY_VENV_BINARY` is needed to know the location of the binary to
        # run.
        "PY_VENV_BINARY": "$(location :" + py_venv_name + ")",
    }

    py_binary(
        name = name,
        srcs = [":build_devenv.py"],
        main = ":build_devenv.py",
        env = env,
        data = [
            ":" + py_venv_name,
            ":" + py_venv_output_json,
        ],
        **kwargs
    )
